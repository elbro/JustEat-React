#1
I built the solution in around 5 hours. I approached the exercise using React as the task was primarily front-end based, and due to the speed/power in being up in running with create-react-app. I used Semantic UI's react library to declaratively design the interface in an aesthetic way in little time, this works exceptionally well with React Components and almost no additional CSS was necessary - and the site is responsive. This also gives Progressive Web App functionality out of the box.

With more time I would have create a better UX for the user by adding sorting and further filtering to allow one to narrow down their choice, automatically displayed nearby restaurants based on location from the browser, and further optimised performance as some areas return 500+ restaurants which can slow down some browsers. I would implement server-side/pre-rendering to statically serve the rendered html making the page far more performant, and consider pagination if necessary. 

#2
Destructuring (and arrow functions!) i.e. `const Restaurant = ({Name, Stars, Logo, Cuisines}) => {}` in ES6.

This saves tedious lines assigning variables, and makes code more declarative as you can quickly see the what the component is using in its signature.

#3
I would monitor application metrics/logs to find which services or functions are running slowly and under what conditions, and implement more granular logging if necessary. In my experience performance issues are often IO related, I would run a database trace in production for half a day to look for patterns in long running events. I have had to do this before with ASP.NET in production, simpler fixes involved optimizing bad SQL queries generated by the ORM and tuning MYSQL settings, and for very slow queries invoking them using Stored Procedures and in-memory tables. I would also run load tests locally while a code profiler (VS is useful for this) is attached to the process to quickly find code bottlenecks.

On the web I spend a lot of time in chrome Network, Performance tools analysing slow requests, rendering. Performance is more important than ever for quality user experiences and this is something I actively think about when designing systems and writing code.

#4
I would add query limit parameters, to not over stress the server and support pagination. I would make the documentation more user-friendly, with explanations for headers, and example usage. As a public API some of the fields are not inherently understandable so I would add human explanations, having the focus on the C# model is not friendly for the external user. 

- It returns 415 unsupported media type instead of bad request, for some malformed queries (GET https://public.je-apis.com/restaurants).
- It returns 502 Bad gateway for single letter queries (https://public.je-apis.com/restaurants?q=a), with a generic error message.
- Why is there a restaurants/v3 endpoint that uses 'Version2.' DTOs?

#5
```
{
  self: {
    eyes: "brown",
    height: "6 ft.",
    nationality: "British",
    diet: "Half-vegetarian",    
    outlook: "positive",
    openMinded: true,
    enthusiasm: 9,
    enjoys: ["Skiing", "Running", "Yoga", "Travelling", "Technology", "Tennis", "Gaming" ] 
    family: [
      {
        name: "Leon",
        relation: "brother"
      },
      {
        name: "Trevor",
        relation: "father"
      },
      {
        name: "Sandy",
        relation: "mother"
      }
    ]
  }
}
```